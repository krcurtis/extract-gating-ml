--------------------------------------------------------------------------------
--- Copyright 2022 Keith Curtis
--- Copyright 2022,2023 Fred Hutchinson Cancer Center
--- Generate XML for GatingML structures

{-# LANGUAGE RecordWildCards #-}

{-

gating:PolygonGate gating:id="Non-Basophils" gating:parent_id="Singlets"


gating:dimension gating:min="3.06371" gating:max="6.42382" gating:compensation-ref="uncompensated" gating:transformation-ref="ArcSinhScale_5_-5_12000"
data-type:fcs-dimension data-type:name="Nd148Di"/


gating:vertex
 <gating:coordinate data-type:value="-0.440932"/>
 <gating:coordinate data-type:value="-0.193526"/>
</gating:vertex>


<gating:RectangleGate gating:id="FSC_Range_Gate">
<gating:dimension
gating:min="10" gating:max="20" gating:compensation-ref="uncompensated">
<data-type:fcs-dimension data-type:name="FSC-H" />
</gating:dimension>
</gating:RectangleGate>


-}

module GatingML2XML where

import Text.XML.Light
import Text.XML.Light.Output

import Data.Maybe (isNothing)
import qualified Data.Text as T
import qualified Data.List as L
import qualified Data.Set as Set

--------------------------------------------------------------------------------

import GatingML
import IntermediateGate (Transform(..))

null_compensation = "uncompensated"
default_compensation = "Comp_M"


pp = useShortEmptyTags (const False) defaultConfigPP


simple_name :: String -> Text.XML.Light.QName
simple_name s = QName s Nothing Nothing

xsi = Attr (simple_name "xmlns:xsi") "http://www.w3.org/2001/XMLSchema-instance"
gating = Attr (simple_name "xmlns:gating") "http://www.isac-net.org/std/Gating-ML/v2.0/gating"
transforms = Attr (simple_name "xmlns:transforms") "http://www.isac-net.org/std/Gating-ML/v2.0/transformations"
datatype = Attr (simple_name "xmlns:data-type") "http://www.isac-net.org/std/Gating-ML/v2.0/datatypes"
schema_location = Attr (simple_name "xsi:schemaLocation") (L.intercalate " "  [ "http://www.isac-net.org/std/Gating-ML/v2.0/gating ../XSD/Gating-ML.v2.0.xsd"
                                                                            , "http://www.isac-net.org/std/Gating-ML/v2.0/transformations ../XSD/Transformations.v2.0.xsd"
                                                                            , "http://www.isac-net.org/std/Gating-ML/v2.0/datatypes ../XSD/DataTypes.v2.0.xsd"])

custom_info = Element { elName = unqual "data-type:custom_info"
                          , elAttribs = [ ]
                          , elContent = [ Text (CData CDataText "Gating-ML generated by extract-gating-ml" Nothing) ]
                          , elLine = Nothing
                          }

top_gatingml = Element { elName = unqual "gating:Gating-ML"
                          , elAttribs = [ xsi, gating, transforms, datatype, schema_location]
                          , elContent = []
                          , elLine = Nothing
                          }


gating_dimension :: GatingDimension -> Element
gating_dimension GatingDimension{..} = full_element
  where
    channel_attribute = Attr (simple_name "data-type:name") (T.unpack gd_name)
    dim_element = Element { elName = unqual "data-type:fcs-dimension"
                          , elAttribs = [ channel_attribute ]
                          , elContent = []
                          , elLine = Nothing
                          }

    attributes' = case gd_minimum of
                    Nothing -> []
                    Just minval -> [Attr (simple_name "gating:min") (show minval)]
    attributes'' = case gd_maximum of
                     Nothing -> attributes'
                     Just maxval -> attributes' ++ [Attr (simple_name "gating:max") (show maxval)]

    compensation_attribute = case gd_compensation_ref of
                               Nothing -> Attr (simple_name "gating:compensation-ref") null_compensation
                               Just x  -> Attr (simple_name "gating:compensation-ref") (T.unpack x)

    attributes = case gd_transformation_ref of
                   Nothing -> attributes'' ++ [compensation_attribute]
                   Just x ->  attributes'' ++ [compensation_attribute, Attr (simple_name "gating:transformation-ref") (T.unpack x)]

    full_element = Element { elName = unqual "gating:dimension"
                           , elAttribs = attributes
                           , elContent = [ Elem dim_element]
                           , elLine = Nothing
                           }

gating_vertex :: (Double, Double) -> Element
gating_vertex (x,y) = full_element
  where
    x_element = Element { elName = unqual "gating:coordinate"
                        , elAttribs = [Attr (simple_name "data-type:value") (show x)]
                        , elContent = []
                        , elLine = Nothing
                        }
    y_element = Element { elName = unqual "gating:coordinate"
                        , elAttribs = [Attr (simple_name "data-type:value") (show y)]
                        , elContent = []
                        , elLine = Nothing
                        }
    full_element = Element { elName = unqual "gating:vertex"
                           , elAttribs = []
                           , elContent = [ Elem x_element, Elem y_element]
                           , elLine = Nothing
                           }


out_example = putStrLn $ ppcTopElement pp
                $ custom_info






-- this could be 1, 2, 3, or more ranges together, but implement 2D version for now
to_gate_element :: Gate -> Element
to_gate_element RectangleGate{..} = full_element
  where
    gate_id_attribute = Attr (simple_name "gating:id") (T.unpack rg_id)
    attributes = case rg_parent_id of
                   Nothing -> [gate_id_attribute]
                   Just x -> [gate_id_attribute, Attr (simple_name "gating:parent_id") (T.unpack x)]
    full_element = Element { elName = unqual "gating:RectangleGate"
                          , elAttribs = attributes
                          , elContent = [ Elem (gating_dimension rg_x_dim), Elem (gating_dimension rg_y_dim)]
                          , elLine = Nothing
                          }
to_gate_element PolygonGate{..} = full_element
  where
    gate_id_attribute = Attr (simple_name "gating:id") (T.unpack pg_id)
    attributes = case pg_parent_id of
                   Nothing -> [gate_id_attribute]
                   Just x -> [gate_id_attribute, Attr (simple_name "gating:parent_id") (T.unpack x)]
    full_element = Element { elName = unqual "gating:PolygonGate"
                          , elAttribs = attributes
                          , elContent = [ Elem (gating_dimension pg_x_dim), Elem (gating_dimension pg_y_dim)] ++ map (Elem . gating_vertex) pg_points
                          , elLine = Nothing
                          }



to_coeff_element :: Double -> Element
to_coeff_element x = full_element
  where
    full_element = Element { elName = unqual "transforms:coefficient"
                           , elAttribs = [ Attr (simple_name "transforms:value") (show x) ]
                           , elContent = []
                           , elLine = Nothing
                           }


to_spectrum_element :: [Double] -> Element
to_spectrum_element coeffs = full_element
  where
    full_element = Element { elName = unqual "transforms:spectrum"
                           , elAttribs = []
                           , elContent = map (Elem . to_coeff_element) coeffs
                           , elLine = Nothing
                           }

to_fluorochromes_element :: [T.Text] -> Element
to_fluorochromes_element fluorochromes = full_element
  where
    to_info_element label = Element { elName = unqual "data-type:fcs-dimension"
                           , elAttribs = [ Attr (simple_name "data-type:name") (T.unpack label) ]
                           , elContent = []
                           , elLine = Nothing
                           }
    full_element = Element { elName = unqual "transforms:fluorochromes"
                           , elAttribs = [ ]
                           , elContent = map (Elem . to_info_element) fluorochromes
                           , elLine = Nothing
                           }


-- flowkit assumes that detector labels correspond to PnN labels
to_detectors_element :: [T.Text] -> Element
to_detectors_element labels = full_element
  where
    to_detector_element label = Element { elName = unqual "data-type:fcs-dimension"
                           , elAttribs = [ Attr (simple_name "data-type:name") (T.unpack label) ]
                           , elContent = []
                           , elLine = Nothing
                           }
    full_element = Element { elName = unqual "transforms:detectors"
                           , elAttribs = [ ]
                           , elContent = map (Elem . to_detector_element) labels
                           , elLine = Nothing
                           }



to_spectrum_matrix_element :: Compensation -> Element
to_spectrum_matrix_element Compensation{..} = full_element
  where
    full_element = Element { elName = unqual "transforms:spectrumMatrix"
                           , elAttribs = [ Attr (simple_name "transforms:id") default_compensation, Attr (simple_name "transforms:matrix-inverted-already") "false" ]
                           , elContent = [ Elem (to_fluorochromes_element c_fluorochromes), Elem (to_detectors_element c_fluorochromes)] ++ map (Elem . to_spectrum_element) c_spectrum_rows
                           , elLine = Nothing
                           }


to_transformation_element :: T.Text -> Transform -> Element
to_transformation_element _ Linear = error "ERROR implemention should not be generating explicit linear transforms for GatingML"
to_transformation_element label (Log paramT paramM) = full_element
  where
    flog = Element { elName = unqual "transforms:flog"
                   , elAttribs = [Attr (simple_name "transforms:T") (show paramT), Attr (simple_name "transforms:M") (show paramM)]
                   , elContent = []
                   , elLine = Nothing
                   }
    full_element = Element { elName = unqual "transforms:transformation"
                           , elAttribs = [ Attr (simple_name "transforms:id") (T.unpack label) ]
                           , elContent  = [Elem flog]
                           , elLine = Nothing
                           }
to_transformation_element label (Biexponential paramT paramW paramM paramA) = full_element
  where
    logicle = Element { elName = unqual "transforms:logicle"
                      , elAttribs = [ Attr (simple_name "transforms:T") (show paramT)
                                    , Attr (simple_name "transforms:W") (show paramW)
                                    , Attr (simple_name "transforms:M") (show paramM)
                                    , Attr (simple_name "transforms:A") (show paramA) ]
                      , elContent = []
                      , elLine = Nothing
                   }
    full_element = Element { elName = unqual "transforms:transformation"
                           , elAttribs = [ Attr (simple_name "transforms:id") (T.unpack label) ]
                           , elContent  = [Elem logicle]
                           , elLine = Nothing
                           }
                                         



to_gates_only_xml :: [Gate] -> Element
to_gates_only_xml gates = top
  where
    top = Element { elName = unqual "gating:Gating-ML"
                          , elAttribs = [ xsi, gating, transforms, datatype, schema_location]
                          , elContent = map (Elem . to_gate_element)  gates
                          , elLine = Nothing
                          }


mark_dim_compensation :: (Set.Set T.Text) -> GatingDimension -> GatingDimension
mark_dim_compensation fluorochromes gdim = gdim'
  where
    gdim' = case (Set.member (gd_name gdim) fluorochromes) of
              False -> gdim
              True -> gdim { gd_compensation_ref = Just . T.pack $ default_compensation }


mark_compensation :: (Set.Set T.Text) -> Gate -> Gate
mark_compensation fluorochromes (RectangleGate aId pId x_dim y_dim) = RectangleGate aId pId x_dim' y_dim'
  where
    x_dim' = mark_dim_compensation fluorochromes x_dim
    y_dim' = mark_dim_compensation fluorochromes y_dim

mark_compensation fluorochromes (PolygonGate aId pId x_dim y_dim points) = PolygonGate aId pId x_dim' y_dim' points
  where
    x_dim' = mark_dim_compensation fluorochromes x_dim
    y_dim' = mark_dim_compensation fluorochromes y_dim



to_xml :: [(Transform, T.Text)] -> Compensation -> [Gate] -> Element
to_xml transform_ref_pairs compensation gates = top
  where
    fluorochromes = Set.fromList . c_fluorochromes $ compensation
    --gates' = map (mark_compensation fluorochromes) gates
    top = Element { elName = unqual "gating:Gating-ML"
                          , elAttribs = [ xsi, gating, transforms, datatype, schema_location]
                          , elContent = concat [ map (Elem . (\(t,label) -> to_transformation_element label t)) transform_ref_pairs
                                               , [Elem . to_spectrum_matrix_element $ compensation]
                                               , map (Elem . to_gate_element)  gates]
                          , elLine = Nothing
                          }

xml_to_file :: String -> Element -> IO ()
xml_to_file filename root = do
  writeFile filename (ppTopElement root)
